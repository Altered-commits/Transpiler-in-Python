from Node import ValueNode, BinaryOperationNode, UnaryOperationNode, VariableAssignNode, VariableAccessNode, IfNode
from EvalTypes import evalTypeToString
from Printer import printError
from Token import tokenOperatorsToString

class Emitter:
    '''
    STAGE 3 of Transpiler: Final stage, Emitter. Responsible for emitting C Code given AST generated by Parser
    Example: For the code given below,
    
    var a = 10;

    Generated C Code:\n
    #include <stdint.h>

    int main(void)
    {
        uint8 a = 10;\n
        return 0;
    }
    '''
    def __init__(self, statements) -> None:
        self.statements = statements
        self.code = ""
        self.indentationLevel = 0
        #Pre-cache some indentation levels
        self.identationCache = {
            0: "",
            1: "    ",
            2: "        ",
            3: "            ",
            4: "                "
        }
    
    #------------Helper functions------------
    def incIndentationLevel(self) -> None:
        self.indentationLevel += 1
    
    def decIndentationLevel(self) -> None:
        self.indentationLevel = max(0, self.indentationLevel - 1)
    
    def getIndentation(self) -> str:
        return self.identationCache.setdefault(self.indentationLevel, " " * (self.indentationLevel * 4))

    #------------Emitter------------
    def emit(self) -> str:
        self.emitHeader()
        self.emitMainFunction()
        return self.code

    def emitHeader(self) -> None:
        #Right now the only usefull header file is <stdint.h>
        self.code += "#include <stdint.h>\n\n"
    
    def emitMainFunction(self) -> None:
        #Start of main function
        self.code += "int main(void)\n{"
        self.incIndentationLevel()
        
        previousNodeType = None
        for statement in self.statements:
            # Add newline for better readability between different types of statements
            if isinstance(statement, VariableAssignNode) and isinstance(previousNodeType, VariableAssignNode):
                if statement.isReassignment != previousNodeType.isReassignment:
                    self.code += "\n"
            elif type(statement) != type(previousNodeType):
                self.code += "\n"
            
            previousNodeType = statement
            self.emitStatement(statement)
        
        self.decIndentationLevel()

        #End of main function
        self.code += "\n    return 0;\n}"
    
    def emitStatement(self, node) -> None:
        shouldEndWithSemic = False
        if(isinstance(node, VariableAssignNode)):
            shouldEndWithSemic = True
            self.emitVariableAssignment(node)
        elif(isinstance(node, IfNode)):
            self.emitIfNode(node)
        #Expression
        else:
            shouldEndWithSemic = True
            self.code += self.getIndentation()
            self.emitExpression(node)
        
        #End statements for now in ';', later we will change this
        if(shouldEndWithSemic):
            self.code += ";\n"
        shouldEndWithSemic = False
    
    def emitIfNode(self, node) -> None:
        self.code += f"{self.getIndentation()}if ("
        self.emitExpression(node.ifCondition)
        self.code += f")\n{self.getIndentation()}" "{\n"
        self.incIndentationLevel()
        
        for statement in node.ifBody:
            self.emitStatement(statement)
        
        self.decIndentationLevel()
        
        self.code += f"{self.getIndentation()}" "}\n"

        #Elifs
        # if(node.elifBlock != [])

    def emitVariableAssignment(self, node) -> None:
        if(node.isReassignment):
            self.code += f"{self.getIndentation()}{node.variableName} = "
            self.emitExpression(node.assignExpr)
        else:
            cType = evalTypeToString(node.variableType)
            if cType is None:
                printError("EmitterError", f"Unsupported cType: {node.variableType}")
            
            self.code += f"{self.getIndentation()}{cType} {node.variableName} = "
            self.emitExpression(node.assignExpr)
    
    def emitExpression(self, node) -> None:
        if isinstance(node, BinaryOperationNode):
            self.emitExpression(node.leftExpr)
            self.code += f" {tokenOperatorsToString[node.operator]} "
            self.emitExpression(node.rightExpr)

        elif isinstance(node, UnaryOperationNode):
            self.code += f"{tokenOperatorsToString[node.operator]}("
            self.emitExpression(node.rightExpr)
            self.code += ")"

        elif isinstance(node, ValueNode):
            self.code += f"{node.value}"

        elif isinstance(node, VariableAccessNode):
            self.code += f"{node.variableName}"
        
        #Re-assignment
        elif isinstance(node, VariableAssignNode):
            #Temporarily reset indentation for nested expressions like these
            oldIndentationLevel = self.indentationLevel
            self.indentationLevel = 0

            self.emitVariableAssignment(node)

            self.indentationLevel = oldIndentationLevel