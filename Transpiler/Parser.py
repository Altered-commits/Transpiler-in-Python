from Lexer         import *
from Node          import *
from EvalTypes     import deduceType, promoteType, mangleFunctionName, evalTypeToString, getMaxBitWidthType, EVAL_VOID, EVAL_STRING
from typing        import Tuple
from TokenAdvancer import TokenAdvancer
from Context       import FunctionContext
from Builtins      import builtinCFunc

class Parser:
    '''
    STAGE 2 of Transpiler: Parser. Responsible for both Syntactic and Semantic Analysis and generation of AST\n
    Example: 10 + 20 / 40;\n
            \t- Passes Syntactic and Semantic Analysis
    AST Generated:\n
           \t- '+'\n
    \t- 10     '/'\n
            \t- 20      40\n
            \t- We traverse the tree and start evaluating from bottom
    '''
    def __init__(self, sourceCode) -> None:
        self.lexer = Lexer(sourceCode)
        #Initialize currentToken to some token generated by getToken()
        self.currentToken = self.lexer.getToken(True)
        #List of statement
        self.statementList = []
        #Temporary symbol table (stack based scope)
        self.parserSymbolTable = [{}]

        #Specifically for global variables
        self.globalSymbolTable = {}

        #List of functions, their details and their templates (with scopes)
        self.funcContext       = FunctionContext()
        self.returnType        = EVAL_VOID
        self.funcTemplates     = [{}]
        self.inlineFuncs       = {}
        self.instantiatedFuncs = {}
    
    def advance(self, isExpr = True) -> None:
        self.currentToken = self.lexer.getToken(isExpr)
    
    def getSpacesAndAdvance(self, isExpr = True) -> str:
        spaceStr          = self.lexer.getAndSkipSpaces()
        self.currentToken = self.lexer.getToken(isExpr)
        return spaceStr

    def peekToken(self, isExpr = True) -> Token:
        return self.lexer.peekToken(isExpr)

    def createTemplateScope(self) -> None:
        self.funcTemplates.append({})

    def createScope(self) -> None:
        self.parserSymbolTable.append({})
    
    def destroyTemplateScope(self) -> None:
        self.funcTemplates.pop()

    def destroyScope(self) -> None:
        self.parserSymbolTable.pop()

    def setTemplateToScope(self, key, value) -> None:
        self.funcTemplates[-1][key] = value

    def setToScope(self, key, value, isGlobal) -> None:
        if isGlobal:
            self.globalSymbolTable[key] = value
        else:
            self.parserSymbolTable[-1][key] = value
    
    def getFromTopScope(self, key, isGlobal) -> object:
        if isGlobal:
            return self.globalSymbolTable.get(key)
        
        return self.parserSymbolTable[-1].get(key)

    def getFromNthScope(self, key, isFunc) -> object | None:
        #Check the global symbol table first
        if key in self.globalSymbolTable:
            return self.globalSymbolTable[key]

        #Determine the starting index based on isFunc, we don't check parser's global table if isFunc
        start_index = len(self.parserSymbolTable) - 1
        end_index = 0 if not isFunc else 1

        #Check in parser's symbol table
        for i in range(start_index, end_index - 1, -1):
            if key in self.parserSymbolTable[i]:
                return self.parserSymbolTable[i][key]

        return None
    
    def getFuncTemplateFromAnyScope(self, key) -> FuncTemplateNode | None:
        for scope in reversed(self.funcTemplates):
            if key in scope:
                return scope.get(key)
        return None
    
    #-----------HELPER METHODS DOWN BELOW-----------
    def parseCommonBinaryOperations(self, leftExprFunction, tokenGroup, rightExprFunction = None):
        if(not rightExprFunction):
           rightExprFunction = leftExprFunction
        
        leftExpr = leftExprFunction()

        #Defined in Token.py
        while (tokenInGroup(self.currentToken.tokenType, tokenGroup)):
            #Save the operator
            operator = self.currentToken.tokenType
            self.advance()

            rightExpr = rightExprFunction()

            #Construct a BinaryOperationNode and assign it to leftExpr
            leftExpr = BinaryOperationNode(leftExpr, operator, rightExpr)
        
        #When done return out of the function
        return leftExpr

    def parseVariableAssignment(self, isGlobal = False):
        identifier = self.currentToken.tokenValue

        if(self.getFromTopScope(identifier, isGlobal) != None):
            errorScope = "global " if isGlobal else ""
            printError("ParserError", f"{errorScope}'{identifier}' identifier already exists, use another one")
        self.advance()

        if(self.currentToken.tokenType != TOKEN_EQ):
            printError("ParserError", "Expected token '=' after identifier")
        self.advance()

        expr = self.parseExpr()

        #Add identifier to symbol table, value being the evaluated type of the variable
        evaluatedType = expr.evaluateExprType()
        if(evaluatedType == EVAL_VOID):
            printError("TypeEvaluatingError", f"variable '{identifier}' was deduced to 'void' type which is not allowed")

        node = VariableAssignNode(evaluatedType, identifier, expr)

        #Store type and ref to the object before returning it
        self.setToScope(identifier, (evaluatedType, node), isGlobal)

        return node

    def parseVariableReassignment(self, identifier, isFunc):
        #Advance over eq token
        self.advance()
        #Using Tuple[] so intellisense properly works
        variable: Tuple[int, VariableAssignNode] = self.getFromNthScope(identifier, isFunc)
        if(variable == None):
            printError("ParserError", f"Undefined identifier to re-assign to: '{identifier}'")
        
        expr = self.parseExpr()
        newType = expr.evaluateExprType()

        #Get the initial variable type (when it was declared)
        initialType = variable[1].variableType

        #Type promotion
        exprType = promoteType(initialType, newType, identifier)

        #Assign newly deduced expression type to the initial declaration of this variable
        variable[1].variableType = exprType
        return VariableAssignNode(exprType, identifier, expr, True)

    def parseBlock(self):
        if(self.currentToken.tokenType != TOKEN_LBRACE):
            printError("ParserError", "Expected '{' after condition")
        self.advance()

        body = []

        while self.currentToken.tokenType != TOKEN_RBRACE and self.currentToken.tokenType != TOKEN_EOF:
            body.append(self.parseStatement())
        
        if(self.currentToken.tokenType != TOKEN_RBRACE):
            printError("ParserError", "Expected ending '}' for statement")
        self.advance()

        return body

    def parseListExpr(self):
        self.advance() #Advance '('

        arguments = []
        while self.currentToken.tokenType != TOKEN_RPAREN:
            arguments.append(self.parseExpr())
            if self.currentToken.tokenType != TOKEN_COMMA:
                break
            self.advance()
        
        if self.currentToken.tokenType != TOKEN_RPAREN:
            printError("ParserError", "Expected ',' or ')' after argument")
        self.advance()

        return arguments

    def parseIfCondition(self):
        ifCondition = self.parseExpr()
        ifBody      = self.parseBlock()
        elseBody    = None

        #List[Tuple[condition, body]]
        elifBlock = []

        while self.currentToken.tokenType == TOKEN_KEYWORD_ELIF:
            self.advance()
            elifCondition = self.parseExpr()
            elifBody      = self.parseBlock()

            elifBlock.append((elifCondition, elifBody))
        
        if(self.currentToken.tokenType == TOKEN_KEYWORD_ELSE):
            self.advance()
            elseBody = self.parseBlock()
        
        return IfNode(ifCondition, ifBody, elifBlock, elseBody)
    
    def parseWhileCondition(self):
        whileCondition = self.parseExpr()
        whileBody      = self.parseBlock()
        
        return WhileNode(whileCondition, whileBody)
    
    def parseForCondition(self):
        if(self.currentToken.tokenType != TOKEN_KEYWORD_VAR):
            printError("ParseError", "Expected 'var' at the starting of assignment in for loop")
        self.advance()

        forAssignment = self.parseVariableAssignment()
        if(self.currentToken.tokenType != TOKEN_SEMIC):
            printError("ParserError", "Expected ';' after assignment")
        self.advance()   

        forCondition  = self.parseExpr()
        if(self.currentToken.tokenType != TOKEN_SEMIC):
            printError("ParserError", "Expected ';' after condition")
        self.advance()

        forIncrement  = self.parseExpr()
        forBody       = self.parseBlock()

        return ForNode(forAssignment, forCondition, forIncrement, forBody)
    
    def parseDoWhileCondition(self):
        dowhileBody = self.parseBlock()
        if(self.currentToken.tokenType != TOKEN_KEYWORD_WHILE):
            printError("ParseError", "Expected 'while' after the body of the do-while loop")
        self.advance()
        dowhileCondition = self.parseExpr()

        return DoWhileNode(dowhileCondition, dowhileBody)

    def parseFuncTemplates(self, isNested = False):
        if self.currentToken.tokenType != TOKEN_IDENTIFIER:
            printError("ParserError", "Expected identifier after keyword 'func'")
        
        funcIdentifier = self.currentToken.tokenValue
        self.advance()

        if self.currentToken.tokenType != TOKEN_LPAREN:
            printError("ParserError", f"Expected '(' after identifier '{funcIdentifier}'")
        self.advance()

        funcParams = []

        #Parse parameters
        while self.currentToken.tokenType != TOKEN_RPAREN:
            if self.currentToken.tokenType != TOKEN_IDENTIFIER:
                printError("ParserError", f"Expected identifier for function parameter in '{funcIdentifier}'")
            funcParams.append(self.currentToken.tokenValue)
            self.advance()

            if self.currentToken.tokenType != TOKEN_COMMA:
                break
            self.advance()
        
        #Closing parenthesis
        if self.currentToken.tokenType != TOKEN_RPAREN:
            printError("ParserError", "Expected closing ')'")
        self.advance()

        if self.currentToken.tokenType != TOKEN_LBRACE:
            printError("ParserError", "Expected opening '{' for function body")
        self.advance()

        funcBody   = []
        braceDepth = 1

        while self.currentToken.tokenType != TOKEN_EOF and braceDepth > 0:
            if self.currentToken.tokenType == TOKEN_RBRACE:
                braceDepth -= 1

            elif self.currentToken.tokenType == TOKEN_LBRACE:
                braceDepth += 1

            if self.currentToken.tokenType == TOKEN_KEYWORD_FUNC:
                self.advance()
                funcBody.append(self.parseFuncTemplates(True))
            else:
                funcBody.append(self.currentToken)
                self.advance()
        
        if braceDepth != 0:
            printError("ParserError", "Expected closing '}' for function body")
        
        #Extra Ending brace of function not needed
        funcBody.pop()

        node = FuncTemplateNode(funcIdentifier, funcParams, funcBody)
        
        if(not isNested):
            self.setTemplateToScope(funcIdentifier, node)

        return node

    def parseFuncDecl(self, funcTemplate, parameterTypes, arguments, funcName, mangledFuncName):
        #Instantiate the function
        self.createScope()
        self.createTemplateScope()
        #Set context
        context = self.funcContext.saveFunctionContext(True, funcName, mangledFuncName)

        functionParameters = list(zip(funcTemplate.funcParams, parameterTypes))
        for idx, (param, paramType) in enumerate(functionParameters):
            self.setToScope(param, (paramType, arguments[idx]), False) #All in their local scope

        #Temporarily replace old lexer with TokenAdvancer and save the state
        oldLexer   = self.lexer
        oldToken   = self.currentToken
        self.lexer = TokenAdvancer(funcTemplate.funcBody)
        
        #Set current token to whatever is present in funcTemplate.funcbody
        self.advance()

        functionBody = []

        while True:
            #Push local templated functions to scope
            if isinstance(self.currentToken, FuncTemplateNode):
                self.setTemplateToScope(self.currentToken.funcName, self.currentToken)
                self.advance()
                continue

            tokenType = self.currentToken.tokenType
            if tokenType == TOKEN_EOF:
                break

            functionBody.append(self.parseStatement())
            #We are handling semicolon / token advancing in parseStatement itself, no need for it here
            
        #Restore old lexer and its state
        self.lexer        = oldLexer
        self.currentToken = oldToken
        self.destroyScope()
        self.destroyTemplateScope()
        #Revert context
        self.funcContext.resetFunctionContext(context)

        instantiatedFunc = FuncDeclNode(mangledFuncName, functionParameters, functionBody, self.returnType)
        self.instantiatedFuncs[mangledFuncName] = instantiatedFunc

        callNode = FuncCallNode(mangledFuncName, arguments, self.returnType)
        self.returnType = EVAL_VOID
        return callNode

    def parseFuncCall(self, funcName):
        arguments = self.parseListExpr()

        funcTemplate  = self.getFuncTemplateFromAnyScope(funcName)
        funcParamsLen = len(funcTemplate.funcParams)
        userArgsLen   = len(arguments)

        if(not funcTemplate):
            printError("ParserError", f"Undefined function: '{funcName}'")

        if(userArgsLen != funcParamsLen):
            printError("ParserError", f"Function '{funcName}' expects {funcParamsLen} argument but got {userArgsLen}")

        #Deduce types for parameters based on actual arguments pass to the function
        parameterTypes = [arg.evaluateExprType() for arg in arguments]

        #Name mangling for function instantiation
        mangledFuncName = mangleFunctionName(funcName, parameterTypes)
        
        #Get the currently on-going function context and check if we are recursively calling it
        _, currentFuncName, currentMangledFuncName = self.funcContext.getFunctionContext() 

        #Recursive call, return node
        if(currentFuncName == funcName):
            #For recursive calls, lets assume the return type will be big, hence we use 64bit variant of current return type
            self.returnType = getMaxBitWidthType(self.returnType)
            return FuncCallNode(currentMangledFuncName, arguments, self.returnType)

        #If function is already instantiated, use it
        function = self.instantiatedFuncs.get(mangledFuncName)
        if function != None:
            return FuncCallNode(mangledFuncName, arguments, function.returnType)

        return self.parseFuncDecl(funcTemplate, parameterTypes, arguments, funcName, mangledFuncName)

    def parseFuncInlineC(self):
        inlineParameters = [] #Last parameter is expected to be return type
        #Advance past the '<' token
        self.advance()

        #First token is always expected to be a __inline_pure__ token no matter what
        if(self.currentToken.tokenType != TOKEN_KEYWORD_INLINE_PURE):
            printError("ParserError", "Expected '__inline_pure__' keyword after '<', 'func<>' syntax not available for normal functions")
        
        self.advance()

        while self.currentToken.tokenType != TOKEN_CMP_GT:
            if(self.currentToken.tokenType != TOKEN_COMMA):
                printError("ParserError", "Expected ',' after '__inline_pure__', or ending '>'")
            self.advance(False)

            if(self.currentToken.tokenType != TOKEN_INT):
                printError("ParserError", "Expected integer type to determine the '__inline_pure__' functions builtin type")
            
            inlineParameters.append(int(self.currentToken.tokenValue))
            self.advance()
        
        #Advance past '>' token
        self.advance()

        #Expect an identifier
        if(self.currentToken.tokenType != TOKEN_IDENTIFIER):
            printError("ParserError", "Expected identifier after '>' symbol")
        
        funcIdentifier = self.currentToken.tokenValue
        self.advance()

        #LPAREN -> '('
        if(self.currentToken.tokenType != TOKEN_LPAREN):
            printError("ParserError", "Expected '(' after identifier")
        self.advance()

        funcParams = []
        hasVargs   = False
        #Parse parameters
        while self.currentToken.tokenType != TOKEN_RPAREN:
            #Variadic arguments, no need for any other arguments, break out of the loop
            if(self.currentToken.tokenType == TOKEN_ELLIPSIS):
                hasVargs = True
                self.advance()
                break

            if(self.currentToken.tokenType != TOKEN_IDENTIFIER):
                printError("ParserError", f"Expected identifier for function parameter in '{funcIdentifier}'")
            paramId = self.currentToken.tokenValue
            self.advance()

            if(self.currentToken.tokenType != TOKEN_COLON):
                printError("ParserError", "Expected ':' after parameter, '__inline_pure__' func mandates type specifying")
            self.advance()

            if(self.currentToken.tokenType != TOKEN_INT):
                printError("ParserError", "Type needs to be an integer, look into TranspilerDefs.txt file")
            paramType = int(self.currentToken.tokenValue)
            self.advance()
            
            funcParams.append((paramId, paramType))

            if self.currentToken.tokenType != TOKEN_COMMA:
                break
            self.advance()

        if(self.currentToken.tokenType != TOKEN_RPAREN):
            printError("ParserError", "Expected closing ')' for function parameters")
        self.advance()

        #If we end function with ';' it means we expect transpiler to fill body for us
        if(self.currentToken.tokenType == TOKEN_SEMIC):
            if(len(inlineParameters) != 2):
                printError("ParserError", "'__inline_pure__' function with no body expects 3 inline paramters: '__inline_pure__', 'builtin_type', 'return_type'")
            self.inlineFuncs[funcIdentifier] = FuncDeclNode(funcIdentifier, funcParams, None, inlineParameters[1],
                                                        True, hasVargs, inlineParameters[0])
            self.advance()
        
        #We have a body
        elif(self.currentToken.tokenType == TOKEN_LBRACE):
            if(len(inlineParameters) != 1):
                printError("ParserError", "'__inline_pure__' function with body expects 2 inline paramters: '__inline_pure__', 'return_type'")            

            self.advance() #Advance past the '{'
            funcBody   = []
            braceCount = 1

            while self.currentToken.tokenType != TOKEN_EOF and braceCount > 0:
                if(self.currentToken.tokenType == TOKEN_LBRACE):
                    braceCount += 1
                elif(self.currentToken.tokenType == TOKEN_RBRACE):
                    braceCount -= 1
                    #All braces done, exit
                    if(braceCount == 0):
                        break
                
                #What we append is simple string values along with spaces, cuz those are necessary for proper indentation and stuff
                funcBody.append(self.currentToken.tokenValue)
                funcBody.append(self.getSpacesAndAdvance())
            
            if(self.currentToken.tokenType != TOKEN_RBRACE):
                printError("ParserError", "Expected ending '}' for '__inline_pure__' function body")
            self.advance()

            self.inlineFuncs[funcIdentifier] = FuncDeclNode(funcIdentifier, funcParams, funcBody, inlineParameters[0],
                                                        True, hasVargs)

        #Invalid syntax
        else:
            printError("ParserError", "Expected either ';' or '{' after '__inline_pure__' function declaration")

    def parseInlineCCall(self, funcDecl):
        arguments = self.parseListExpr()

        funcParamsLen = len(funcDecl.funcParams)
        userArgsLen   = len(arguments)

        if(funcDecl.hasVargs):
            #Removing '...' from args len of function
            if(userArgsLen < funcParamsLen):
                printError("ParserError", f"Function '{funcDecl.funcName}' expected atleast {funcParamsLen} argument but got {userArgsLen}")
        #Len of both func and user args need to be same need to be the same
        elif(userArgsLen != funcParamsLen):
            printError("ParserError", f"Function '{funcDecl.funcName}' expects {funcParamsLen} argument but got {userArgsLen}")

        #Builtin stuff
        if(funcDecl.funcBody is None):
            return InlinePureFuncNode(builtinCFunc(funcDecl, arguments), funcDecl.returnType, True)

        #Inline with function body (list of strings)
        inlineCCode = ""
        #Parameter is tuple of identifier and datatype, arg is a ast node
        paramReplacementDict = {}        
        for param, arg in zip(funcDecl.funcParams, arguments):
            #Get the argument datatype
            argType    = arg.evaluateExprType()
            argValue   = arg.__repr__()
            paramType  = param[1]
            paramValue = param[0]
            
            #If the type doesn't match that of function parameters type, its an error
            if(promoteType(argType, paramType, argValue, isArgumentType=True) < 0):
                printError("InlineFuncError",
                        f"Parameter's datatype ({argValue}:{evalTypeToString(argType)}) cannot be implicitly casted to argument ({paramValue}:{evalTypeToString(paramType)})"
                        f" of inline function '{funcDecl.funcName}'")

            #Type matches, add it to replacement dict
            paramReplacementDict[paramValue] = argValue

        #funcBody -> List[str]
        funcBodyLen = len(funcDecl.funcBody)
        for idx, stringTokens in enumerate(funcDecl.funcBody):
            if(stringTokens == ''):
                continue
            #Only add the last newline if the last token before the newline is right brace, else just don't even add it
            if(idx == funcBodyLen - 1 and funcDecl.funcBody[idx - 1] != '}'):
                continue
            #Replace tokens or add it as is to the inlineCCode
            inlineCCode += paramReplacementDict.get(stringTokens, stringTokens)

        return InlinePureFuncNode(inlineCCode, funcDecl.returnType)

    #-----------PARSING METHODS DOWN BELOW-----------
    def parse(self):
        while self.currentToken.tokenType != TOKEN_EOF:
            statement = self.parseStatement()
            if statement is not None:
                self.statementList.append(statement)
        
        return self.statementList, self.instantiatedFuncs, self.globalSymbolTable

    #keywords | expr
    def parseStatement(self):
        tokenType = self.currentToken.tokenType
        statement = None

        if(self.currentToken.tokenType == TOKEN_KEYWORD_GLOBAL):
            self.advance()
            if(self.currentToken.tokenType != TOKEN_KEYWORD_VAR):
                printError("ParserError", "'global' only applicable to variables, expected 'var' after 'global'")

            self.advance()
            self.parseVariableAssignment(True)

        elif(self.currentToken.tokenType == TOKEN_KEYWORD_VAR):
            self.advance()
            statement = self.parseVariableAssignment()

        elif(self.currentToken.tokenType == TOKEN_KEYWORD_IF):
            self.advance()
            self.createScope()
            statement = self.parseIfCondition()
            self.destroyScope()
        
        elif(self.currentToken.tokenType == TOKEN_KEYWORD_WHILE):
            self.advance()
            self.createScope()
            statement = self.parseWhileCondition()
            self.destroyScope()

        elif(self.currentToken.tokenType == TOKEN_KEYWORD_FOR):
            self.advance()
            self.createScope()
            statement = self.parseForCondition()
            self.destroyScope()    

        elif(self.currentToken.tokenType == TOKEN_KEYWORD_DO):
            self.advance()
            self.createScope()
            statement = self.parseDoWhileCondition()
            self.destroyScope() 
        
        elif(self.currentToken.tokenType == TOKEN_KEYWORD_FUNC):
            self.advance()
            if(self.currentToken.tokenType == TOKEN_CMP_LT):
                self.parseFuncInlineC()
            else:
                self.parseFuncTemplates()

        elif(self.currentToken.tokenType == TOKEN_KEYWORD_RETURN):
            context = self.funcContext.getFunctionContext()
            #Can we return?
            if not context[0]:
                printError("ParserError", "'return' cannot be outside of function declaration")
            self.advance()

            rExpr = self.parseExpr()
            statement = ReturnNode(rExpr)
            self.returnType = promoteType(self.returnType, statement.evaluateExprType(), context[1], True)\
                                  if self.returnType != EVAL_VOID\
                                  else statement.evaluateExprType()

        else:
            statement = self.parseExpr()
        
        if(tokenType < TOKEN_KEYWORD_IF):
            if(self.currentToken.tokenType != TOKEN_SEMIC):
                printError("ParserError", "Expected ';' after expression")
            self.advance()
        
        return statement

    #and, or, variable reassignment
    def parseExpr(self):
        if(self.currentToken.tokenType == TOKEN_IDENTIFIER):
            if(self.peekToken().tokenType == TOKEN_EQ):
                identifier = self.currentToken.tokenValue

                self.advance()
                return self.parseVariableReassignment(identifier, self.funcContext.isFuncCurrently())

        return self.parseCommonBinaryOperations(self.parseComparisionExpr, LOGICAL_GROUP)

    #not, comparision operators
    def parseComparisionExpr(self):
        if(self.currentToken.tokenType == TOKEN_KEYWORD_NOT):
            operator = self.currentToken.tokenType
            self.advance()

            rightExpr = self.parseComparisionExpr()

            return UnaryOperationNode(operator, rightExpr)

        #Else we just look for comparision operators ig
        return self.parseCommonBinaryOperations(self.parseArithmeticExpr, COMPARISION_GROUP)

    def parseArithmeticExpr(self):
        return self.parseCommonBinaryOperations(self.parseTerm, ARITHMETIC_GROUP)

    def parseTerm(self):
        return self.parseCommonBinaryOperations(self.parseUnary, TERM_GROUP)

    def parseUnary(self):
        #We only allow minus as UnaryOperation, for now
        if(self.currentToken.tokenType == TOKEN_SUB):
            operator = self.currentToken.tokenType
            self.advance()

            rightExpr = self.parseUnary()

            return UnaryOperationNode(operator, rightExpr)
        
        #Else we just return an Atom
        return self.parseCall()

    def parseCall(self):
        atom = self.parseAtom()

        #Check for proper function call if the current token is identifier and its next token is '('
        if(self.currentToken.tokenType == TOKEN_IDENTIFIER and self.peekToken().tokenType == TOKEN_LPAREN):
            self.advance()
            #Function Template
            if(isinstance(atom, Token)):
                return self.parseFuncCall(atom.tokenValue)
            
            #Inline Pure
            elif(isinstance(atom, FuncDeclNode)):
                return self.parseInlineCCall(atom)
            
            #Error
            else:
                printError("ParserError", "Current type is not callable")
        
        return atom

    def parseAtom(self):
        if(tokenInGroup(self.currentToken.tokenType, PRIMITIVE_GROUP)):
            node = None
            
            if(self.currentToken.tokenType == TOKEN_STRING):
                node = ValueNode(self.currentToken.tokenValue, EVAL_STRING)
            else:
                value, evalType = deduceType(self.currentToken.tokenValue, self.currentToken.tokenType == TOKEN_FLOAT, 
                                                                        self.currentToken.tokenType == TOKEN_CHAR)
                node = ValueNode(value, evalType)
            
            self.advance()
            return node
        
        if(self.currentToken.tokenType == TOKEN_IDENTIFIER):
            if(self.getFuncTemplateFromAnyScope(self.currentToken.tokenValue)):
                return self.currentToken

            #Inline Pure func
            if(self.currentToken.tokenValue in self.inlineFuncs):
                return self.inlineFuncs[self.currentToken.tokenValue]
            
            #Get variable type from the parserSymbolTable
            variable = self.getFromNthScope(self.currentToken.tokenValue, self.funcContext.isFuncCurrently())
            if(variable == None):
                printError("ParserError", f"Undefined identifier: {self.currentToken.tokenValue}")
            identifierType = variable[0]

            node = VariableAccessNode(identifierType, self.currentToken.tokenValue)
            self.advance()
            
            return node

        #If we find '(' then change order of operations
        if(self.currentToken.tokenType == TOKEN_LPAREN):
            self.advance()
            expr = self.parseExpr()

            #Check for closing ')'
            if(self.currentToken.tokenType != TOKEN_RPAREN):
                printError("ParserError", "Expected closing ')'")
            self.advance()

            return ParenthesizedNode(expr)

        #All of the other stuff is just error
        printError("ParserError", "Expected Primitive types or '()' expression")