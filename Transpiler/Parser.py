from Lexer         import *
from Node          import *
from EvalTypes     import deduceType, promoteType, mangleFunctionName, EVAL_VOID
from typing        import Tuple
from TokenAdvancer import TokenAdvancer
from Context       import FunctionContext

class Parser:
    '''
    STAGE 2 of Transpiler: Parser. Responsible for both Syntactic and Semantic Analysis and generation of AST\n
    Example: 10 + 20 / 40;\n
            \t- Passes Syntactic and Semantic Analysis
    AST Generated:\n
           \t- '+'\n
    \t- 10     '/'\n
            \t- 20      40\n
            \t- We traverse the tree and start evaluating from bottom
    '''
    def __init__(self, sourceCode) -> None:
        self.lexer = Lexer(sourceCode)
        #Initialize currentToken to some token generated by getToken()
        self.currentToken = self.lexer.getToken()
        #List of statement
        self.statementList = []
        #Temporary symbol table (stack based scope)
        self.parserSymbolTable = [{}]

        #Specifically for global variables
        self.globalSymbolTable = {}

        #List of functions, their details and their templates (with scopes)
        self.funcContext = FunctionContext()
        self.returnType = EVAL_VOID
        self.funcTemplates = [{}]
        self.instantiatedFuncs = {}
    
    def advance(self) -> None:
        self.currentToken = self.lexer.getToken()

    def peekToken(self) -> Token:
        return self.lexer.peekToken()

    def createTemplateScope(self) -> None:
        self.funcTemplates.append({})

    def createScope(self) -> None:
        self.parserSymbolTable.append({})
    
    def destroyTemplateScope(self) -> None:
        self.funcTemplates.pop()

    def destroyScope(self) -> None:
        self.parserSymbolTable.pop()

    def setTemplateToScope(self, key, value) -> None:
        self.funcTemplates[-1][key] = value

    def setToScope(self, key, value, isGlobal) -> None:
        if isGlobal:
            self.globalSymbolTable[key] = value
        else:
            self.parserSymbolTable[-1][key] = value
    
    def getFromTopScope(self, key, isGlobal) -> object:
        if isGlobal:
            return self.globalSymbolTable.get(key)
        
        return self.parserSymbolTable[-1].get(key)

    def getFromNthScope(self, key, isFunc) -> object | None:
        #Check the global symbol table first
        if key in self.globalSymbolTable:
            return self.globalSymbolTable[key]

        #Determine the starting index based on isFunc, we don't check parser's global table if isFunc
        start_index = len(self.parserSymbolTable) - 1
        end_index = 0 if not isFunc else 1

        #Check in parser's symbol table
        for i in range(start_index, end_index - 1, -1):
            if key in self.parserSymbolTable[i]:
                return self.parserSymbolTable[i][key]

        return None
    
    def getFuncTemplateFromAnyScope(self, key) -> FuncTemplateNode | None:
        for scope in reversed(self.funcTemplates):
            if key in scope:
                return scope.get(key)
        return None
    
    #-----------HELPER METHODS DOWN BELOW-----------
    def parseCommonBinaryOperations(self, leftExprFunction, tokenGroup, rightExprFunction = None):
        if(not rightExprFunction):
           rightExprFunction = leftExprFunction
        
        leftExpr = leftExprFunction()

        #Defined in Token.py
        while (tokenInGroup(self.currentToken.tokenType, tokenGroup)):
            #Save the operator
            operator = self.currentToken.tokenType
            self.advance()

            rightExpr = rightExprFunction()

            #Construct a BinaryOperationNode and assign it to leftExpr
            leftExpr = BinaryOperationNode(leftExpr, operator, rightExpr)
        
        #When done return out of the function
        return leftExpr

    def parseVariableAssignment(self, isGlobal = False):
        identifier = self.currentToken.tokenValue

        if(self.getFromTopScope(identifier, isGlobal) != None):
            errorScope = "global " if isGlobal else ""
            printError("ParserError", f"{errorScope}'{identifier}' identifier already exists, use another one")
        self.advance()

        if(self.currentToken.tokenType != TOKEN_EQ):
            printError("ParserError", "Expected token '=' after identifier")
        self.advance()

        expr = self.parseExpr()

        #Add identifier to symbol table, value being the evaluated type of the variable
        evaluatedType = expr.evaluateExprType()
        if(evaluatedType == EVAL_VOID):
            printError("TypeEvaluatingError", f"variable '{identifier}' was deduced to 'void' type which is not allowed")

        node = VariableAssignNode(evaluatedType, identifier, expr)

        #Store type and ref to the object before returning it
        self.setToScope(identifier, (evaluatedType, node), isGlobal)

        return node

    def parseVariableReassignment(self, identifier, isFunc):
        #Advance over eq token
        self.advance()
        #Using Tuple[] so intellisense properly works
        variable: Tuple[int, VariableAssignNode] = self.getFromNthScope(identifier, isFunc)
        if(variable == None):
            printError("ParserError", f"Undefined identifier to re-assign to: '{identifier}'")
        
        expr = self.parseExpr()
        newType = expr.evaluateExprType()

        #Get the initial variable type (when it was declared)
        initialType = variable[1].variableType

        #Type promotion
        exprType = promoteType(initialType, newType, identifier)

        #Assign newly deduced expression type to the initial declaration of this variable
        variable[1].variableType = exprType
        return VariableAssignNode(exprType, identifier, expr, True)

    def parseBlock(self):
        if(self.currentToken.tokenType != TOKEN_LBRACE):
            printError("ParserError", "Expected '{' after condition")
        self.advance()

        body = []

        while self.currentToken.tokenType != TOKEN_RBRACE and self.currentToken.tokenType != TOKEN_EOF:
            body.append(self.parseStatement())
        
        if(self.currentToken.tokenType != TOKEN_RBRACE):
            printError("ParserError", "Expected ending '}' for statement")
        self.advance()

        return body

    def parseIfCondition(self):
        ifCondition = self.parseExpr()
        ifBody      = self.parseBlock()
        elseBody    = None

        #List[Tuple[condition, body]]
        elifBlock = []

        while self.currentToken.tokenType == TOKEN_KEYWORD_ELIF:
            self.advance()
            elifCondition = self.parseExpr()
            elifBody      = self.parseBlock()

            elifBlock.append((elifCondition, elifBody))
        
        if(self.currentToken.tokenType == TOKEN_KEYWORD_ELSE):
            self.advance()
            elseBody = self.parseBlock()
        
        return IfNode(ifCondition, ifBody, elifBlock, elseBody)
    
    def parseWhileCondition(self):
        whileCondition = self.parseExpr()
        whileBody      = self.parseBlock()
        
        return WhileNode(whileCondition, whileBody)
    
    def parseForCondition(self):
        if(self.currentToken.tokenType != TOKEN_KEYWORD_VAR):
            printError("ParseError", "Expected 'var' at the starting of assignment in for loop")
        self.advance()

        forAssignment = self.parseVariableAssignment()
        if(self.currentToken.tokenType != TOKEN_SEMIC):
            printError("ParserError", "Expected ';' after assignment")
        self.advance()   

        forCondition  = self.parseExpr()
        if(self.currentToken.tokenType != TOKEN_SEMIC):
            printError("ParserError", "Expected ';' after condition")
        self.advance()

        forIncrement  = self.parseExpr()
        forBody       = self.parseBlock()

        return ForNode(forAssignment, forCondition, forIncrement, forBody)

    def parseFuncTemplates(self, isNested = False):
        if self.currentToken.tokenType != TOKEN_IDENTIFIER:
            printError("ParserError", "Expected identifier after keyword 'func'")
        
        funcIdentifier = self.currentToken.tokenValue
        self.advance()

        if self.currentToken.tokenType != TOKEN_LPAREN:
            printError("ParserError", f"Expected '(' after identifier '{funcIdentifier}'")
        self.advance()

        funcParams = []

        # Parse parameters
        while self.currentToken.tokenType != TOKEN_RPAREN:
            if self.currentToken.tokenType != TOKEN_IDENTIFIER:
                printError("ParserError", f"Expected identifier for function parameter in '{funcIdentifier}'")
            funcParams.append(self.currentToken.tokenValue)
            self.advance()

            if self.currentToken.tokenType != TOKEN_COMMA:
                break
            self.advance()
        
        # Closing parenthesis
        if self.currentToken.tokenType != TOKEN_RPAREN:
            printError("ParserError", "Expected closing ')'")
        self.advance()

        if self.currentToken.tokenType != TOKEN_LBRACE:
            printError("ParserError", "Expected opening '{' for function body")
        self.advance()

        funcBody   = []
        braceDepth = 1

        while self.currentToken.tokenType != TOKEN_EOF and braceDepth > 0:
            if self.currentToken.tokenType == TOKEN_RBRACE:
                braceDepth -= 1

            elif self.currentToken.tokenType == TOKEN_LBRACE:
                braceDepth += 1

            if self.currentToken.tokenType == TOKEN_KEYWORD_FUNC:
                self.advance()
                funcBody.append(self.parseFuncTemplates(True))
            else:
                funcBody.append(self.currentToken)
                self.advance()
        
        if braceDepth != 0:
            printError("ParserError", "Expected closing '}' for function body")
        
        #Extra Ending brace of function not needed
        funcBody.pop()

        node = FuncTemplateNode(funcIdentifier, funcParams, funcBody)
        
        if(not isNested):
            self.setTemplateToScope(funcIdentifier, node)

        return node

    def parseFuncDecl(self, funcTemplate, parameterTypes, arguments, funcName, mangledFuncName):
        #Instantiate the function
        self.createScope()
        self.createTemplateScope()
        #Set context
        context = self.funcContext.saveFunctionContext(True, funcName)

        functionParameters = list(zip(funcTemplate.funcParams, parameterTypes))
        for idx, (param, paramType) in enumerate(functionParameters):
            self.setToScope(param, (paramType, arguments[idx]), False) #All in their local scope

        # Temporarily replace old lexer with TokenAdvancer and save the state
        oldLexer   = self.lexer
        oldToken   = self.currentToken
        self.lexer = TokenAdvancer(funcTemplate.funcBody)
        
        #Set current token to whatever is present in funcTemplate.funcbody
        self.advance()

        functionBody = []

        while True:
            #Push local templated functions to scope
            if isinstance(self.currentToken, FuncTemplateNode):
                self.setTemplateToScope(self.currentToken.funcName, self.currentToken)
                self.advance()
                continue

            tokenType = self.currentToken.tokenType
            if tokenType == TOKEN_EOF:
                break

            functionBody.append(self.parseStatement())
            #We are handling semicolon / token advancing in parseStatement itself, no need for it here
            
        #Restore old lexer and its state
        self.lexer        = oldLexer
        self.currentToken = oldToken
        self.destroyScope()
        self.destroyTemplateScope()
        #Revert context
        self.funcContext.resetFunctionContext(context)

        instantiatedFunc = FuncDeclNode(mangledFuncName, functionParameters, functionBody, self.returnType)
        self.instantiatedFuncs[mangledFuncName] = instantiatedFunc

        callNode = FuncCallNode(mangledFuncName, arguments, self.returnType)
        self.returnType = EVAL_VOID
        return callNode

    def parseFuncCall(self, funcName):
        self.advance() # Advance '('

        arguments = []
        while self.currentToken.tokenType != TOKEN_RPAREN:
            arguments.append(self.parseExpr())
            if self.currentToken.tokenType != TOKEN_COMMA:
                break
            self.advance()
        
        if self.currentToken.tokenType != TOKEN_RPAREN:
            printError("ParserError", "Expected ',' or ')' after argument")
        self.advance()

        funcTemplate = self.getFuncTemplateFromAnyScope(funcName)
        funcArgsLen  = len(funcTemplate.funcParams)
        userArgsLen  = len(arguments)

        if not funcTemplate:
            printError("ParserError", f"Undefined function: '{funcName}'")

        if userArgsLen != funcArgsLen:
            printError("ParserError", f"Function '{funcName}' expects {funcArgsLen} argument but got {userArgsLen}")

        # Deduce types for parameters based on actual arguments pass to the function
        parameterTypes = [arg.evaluateExprType() for arg in arguments]

        # Name mangling for function instantiation
        mangledFuncName = mangleFunctionName(funcName, parameterTypes)

        # If function is already instantiated, use it
        function = self.instantiatedFuncs.get(mangledFuncName)
        if function != None:
            return FuncCallNode(mangledFuncName, arguments, function.returnType)

        return self.parseFuncDecl(funcTemplate, parameterTypes, arguments, funcName, mangledFuncName)

    #-----------PARSING METHODS DOWN BELOW-----------
    def parse(self):
        while self.currentToken.tokenType != TOKEN_EOF:
            statement = self.parseStatement()
            if statement is not None:
                self.statementList.append(statement)
        
        return self.statementList, self.instantiatedFuncs, self.globalSymbolTable

    #var keyword | expr
    def parseStatement(self):
        tokenType = self.currentToken.tokenType
        statement = None

        if(self.currentToken.tokenType == TOKEN_KEYWORD_GLOBAL):
            self.advance()
            if(self.currentToken.tokenType != TOKEN_KEYWORD_VAR):
                printError("ParserError", "'global' only applicable to variables, expected 'var' after 'global'")

            self.advance()
            self.parseVariableAssignment(True)

        elif(self.currentToken.tokenType == TOKEN_KEYWORD_VAR):
            self.advance()
            statement = self.parseVariableAssignment()

        elif(self.currentToken.tokenType == TOKEN_KEYWORD_IF):
            self.advance()
            self.createScope()
            statement = self.parseIfCondition()
            self.destroyScope()
        
        elif(self.currentToken.tokenType == TOKEN_KEYWORD_WHILE):
            self.advance()
            self.createScope()
            statement = self.parseWhileCondition()
            self.destroyScope()

        elif(self.currentToken.tokenType == TOKEN_KEYWORD_FOR):
            self.advance()
            self.createScope()
            statement = self.parseForCondition()
            self.destroyScope()    
        
        elif(self.currentToken.tokenType == TOKEN_KEYWORD_FUNC):
            self.advance()
            self.parseFuncTemplates()

        elif(self.currentToken.tokenType == TOKEN_KEYWORD_RETURN):
            context = self.funcContext.getFunctionContext()
            #Can we return?
            if not context[0]:
                printError("ParserError", "'return' cannot be outside of function declaration")
            self.advance()

            rExpr = self.parseExpr()
            statement = ReturnNode(rExpr)
            self.returnType = promoteType(self.returnType, statement.evaluateExprType(), context[1], True)\
                                  if self.returnType != EVAL_VOID\
                                  else statement.evaluateExprType()

        else:
            statement = self.parseExpr()
        
        if(tokenType < TOKEN_KEYWORD_IF):
            if(self.currentToken.tokenType != TOKEN_SEMIC):
                printError("ParserError", "Expected ';' after expression")
            self.advance()
        
        return statement

    #and, or, variable reassignment
    def parseExpr(self):
        if(self.currentToken.tokenType == TOKEN_IDENTIFIER):
            if(self.peekToken().tokenType == TOKEN_EQ):
                identifier = self.currentToken.tokenValue

                self.advance()
                return self.parseVariableReassignment(identifier, self.funcContext.isFuncCurrently())

        return self.parseCommonBinaryOperations(self.parseComparisionExpr, LOGICAL_GROUP)

    #not, comparision operators
    def parseComparisionExpr(self):
        if(self.currentToken.tokenType == TOKEN_KEYWORD_NOT):
            operator = self.currentToken.tokenType
            self.advance()

            rightExpr = self.parseComparisionExpr()

            return UnaryOperationNode(operator, rightExpr)

        #Else we just look for comparision operators ig
        return self.parseCommonBinaryOperations(self.parseArithmeticExpr, COMPARISION_GROUP)

    def parseArithmeticExpr(self):
        return self.parseCommonBinaryOperations(self.parseTerm, ARITHMETIC_GROUP)

    def parseTerm(self):
        return self.parseCommonBinaryOperations(self.parseUnary, TERM_GROUP)

    def parseUnary(self):
        #We only allow minus as UnaryOperation, for now
        if(self.currentToken.tokenType == TOKEN_SUB):
            operator = self.currentToken.tokenType
            self.advance()

            #Every time we get minus, we invert this condition, if even number of minus, this condition will be false
            rightExpr = self.parseUnary()

            #Return an UnaryOperationNode
            return UnaryOperationNode(operator, rightExpr)
        
        #Else we just return an Atom
        return self.parseCall()

    def parseCall(self):
        atom = self.parseAtom()

        # Function call, needs identifier
        if isinstance(atom, Token):
            self.advance()
            if self.currentToken.tokenType == TOKEN_LPAREN:
                return self.parseFuncCall(atom.tokenValue)
            else:
                printError("ParserError", f"Function call expected '(' after identifier")
        
        return atom

    def parseAtom(self):
        if(self.currentToken.tokenType in (TOKEN_INT, TOKEN_FLOAT, TOKEN_CHAR)):
            value, evalType = deduceType(self.currentToken.tokenValue, self.currentToken.tokenType == TOKEN_FLOAT, 
                                                                        self.currentToken.tokenType == TOKEN_CHAR)
            
            node = ValueNode(value, evalType)
            self.advance()

            return node
        
        if(self.currentToken.tokenType == TOKEN_IDENTIFIER):
            if self.getFuncTemplateFromAnyScope(self.currentToken.tokenValue):
                return self.currentToken
            
            #Get variable type from the parserSymbolTable
            variable = self.getFromNthScope(self.currentToken.tokenValue, self.funcContext.isFuncCurrently())
            if(variable == None):
                printError("ParserError", f"Undefined variable: {self.currentToken.tokenValue}")
            
            identifierType = variable[0]

            node = VariableAccessNode(identifierType, self.currentToken.tokenValue)
            self.advance()
            
            return node

        #If we find '(' then change order of operations
        if(self.currentToken.tokenType == TOKEN_LPAREN):
            self.advance()
            expr = self.parseExpr()

            #Check for closing ')'
            if(self.currentToken.tokenType != TOKEN_RPAREN):
                printError("ParserError", "Expected closing ')'")
            self.advance()

            return expr

        #All of the other stuff is just error
        printError("ParserError", "Expected Primitive types or '()' expression")