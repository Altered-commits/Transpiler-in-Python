from Lexer import *
from Node  import *
from EvalTypes import deduceType, promoteType
from typing import Tuple

class Parser:
    '''
    STAGE 2 of Transpiler: Parser. Responsible for both Syntactic and Semantic Analysis and generation of AST\n
    Example: 10 + 20 / 40;\n
            \t- Passes Syntactic and Semantic Analysis
    AST Generated:\n
           \t- '+'\n
    \t- 10     '/'\n
            \t- 20      40\n
            \t- We traverse the tree and start evaluating from bottom
    '''
    def __init__(self, sourceCode) -> None:
        self.lexer = Lexer(sourceCode)
        #Initialize currentToken to some token generated by lex()
        self.currentToken = self.lexer.lex()
        #List of statement
        self.statementList = []
        #Temporary symbol table (stack based scope)
        self.parserSymbolTable = [{}]
    
    def advance(self) -> None:
        self.currentToken = self.lexer.lex()

    def peekToken(self) -> Token:
        return self.lexer.peekToken()

    def createScope(self) -> None:
        self.parserSymbolTable.append({})
    
    def destroyScope(self) -> None:
        self.parserSymbolTable.pop()

    def setToScope(self, key, value) -> None:
        self.parserSymbolTable[-1][key] = value
    
    def getFromTopScope(self, key):
        return self.parserSymbolTable[-1].get(key)

    def getFromNthScope(self, key):
        for i in reversed(self.parserSymbolTable):
            if key in i:
                return i.get(key)
    
    #-----------HELPER METHODS DOWN BELOW-----------
    def parseCommonBinaryOperations(self, leftExprFunction, tokenGroup, rightExprFunction = None):
        if(not rightExprFunction):
           rightExprFunction = leftExprFunction
        
        leftExpr = leftExprFunction()

        #Defined in Token.py
        while (tokenInGroup(self.currentToken.tokenType, tokenGroup)):
            #Save the operator
            operator = self.currentToken.tokenType
            self.advance()

            rightExpr = rightExprFunction()

            #Construct a BinaryOperationNode and assign it to leftExpr
            leftExpr = BinaryOperationNode(leftExpr, operator, rightExpr)
        
        #When done return out of the function
        return leftExpr

    def parseVariableAssignment(self):
        identifier = self.currentToken.tokenValue
        if(self.getFromTopScope(identifier) != None):
            printError("ParserError", f"'{identifier}' identifier already exists, use another one")
        self.advance()

        if(self.currentToken.tokenType != TOKEN_EQ):
            printError("ParserError", "Expected token '=' after identifier")
        self.advance()

        expr = self.parseExpr()

        #Add identifier to symbol table, value being the evaluated type of the variable
        evaluatedType = expr.evaluateExprType()
        node = VariableAssignNode(evaluatedType, identifier, expr)

        #Store type and ref to the object before returning it
        self.setToScope(identifier, (evaluatedType, node))

        return node

    def parseVariableReassignment(self, identifier):
        #Advance over eq token
        self.advance()
        #Using Tuple[] so intellisense properly works
        variable: Tuple[int, VariableAssignNode] = self.getFromNthScope(identifier)
        if(variable == None):
            printError("ParserError", f"Undefined identifier to re-assign to: '{identifier}'")
        
        expr = self.parseExpr()
        newType = expr.evaluateExprType()

        #Get the initial variable type (when it was declared)
        initialType = variable[1].variableType

        #Type promotion
        exprType = promoteType(initialType, newType, identifier)

        #Assign newly deduced expression type to the initial declaration of this variable
        variable[1].variableType = exprType
        return VariableAssignNode(exprType, identifier, expr, True)

    def parseBlock(self):
        if(self.currentToken.tokenType != TOKEN_LBRACE):
            printError("ParserError", "Expected '{' after condition")
        self.advance()

        body = []

        while self.currentToken.tokenType != TOKEN_RBRACE and self.currentToken.tokenType != TOKEN_EOF:
            body.append(self.parseStatement())
        
        if(self.currentToken.tokenType != TOKEN_RBRACE):
            printError("ParserError", "Expected ending '}' for statement")
        self.advance()

        return body

    def parseIfCondition(self):
        ifCondition = self.parseExpr()
        ifBody      = self.parseBlock()
        elseBody    = None

        #List[Tuple[condition, body]]
        elifBlock = []

        while self.currentToken.tokenType == TOKEN_KEYWORD_ELIF:
            self.advance()
            elifCondition = self.parseExpr()
            elifBody      = self.parseBlock()

            elifBlock.append((elifCondition, elifBody))
        
        if(self.currentToken.tokenType == TOKEN_KEYWORD_ELSE):
            self.advance()
            elseBody = self.parseBlock()
        
        return IfNode(ifCondition, ifBody, elifBlock, elseBody)
    
    def parseWhileCondition(self):
        whileCondition = self.parseExpr()
        whileBody      = self.parseBlock()
        
        return WhileNode(whileCondition, whileBody)
    
    def parseForCondition(self):
        if(self.currentToken.tokenType != TOKEN_KEYWORD_VAR):
            printError("ParseError", "Expected 'var' at the starting of assignment in for loop")
        self.advance()

        forAssignment = self.parseVariableAssignment()
        if(self.currentToken.tokenType != TOKEN_SEMIC):
            printError("ParserError", "Expected ';' after assignment")
        self.advance()   

        forCondition  = self.parseExpr()
        if(self.currentToken.tokenType != TOKEN_SEMIC):
            printError("ParserError", "Expected ';' after condition")
        self.advance()

        forIncrement  = self.parseExpr()
        forBody       = self.parseBlock()

        return ForNode(forAssignment, forCondition, forIncrement, forBody)

    #-----------PARSING METHODS DOWN BELOW-----------
    def parse(self):
        while self.currentToken.tokenType != TOKEN_EOF:
            self.statementList.append(self.parseStatement())
        
        return self.statementList

    #var keyword | expr
    def parseStatement(self):
        tokenType = self.currentToken.tokenType
        statement = None

        if(self.currentToken.tokenType == TOKEN_KEYWORD_VAR):
            self.advance()
            statement = self.parseVariableAssignment()

        elif(self.currentToken.tokenType == TOKEN_KEYWORD_IF):
            self.advance()
            self.createScope()
            statement = self.parseIfCondition()
            self.destroyScope()
        
        elif(self.currentToken.tokenType == TOKEN_KEYWORD_WHILE):
            self.advance()
            self.createScope()
            statement = self.parseWhileCondition()
            self.destroyScope()

        elif(self.currentToken.tokenType == TOKEN_KEYWORD_FOR):
            self.advance()
            self.createScope()
            statement = self.parseForCondition()
            self.destroyScope()    
        
        else:
            statement = self.parseExpr()
        
        if(tokenType < TOKEN_KEYWORD_IF):
            if(self.currentToken.tokenType != TOKEN_SEMIC):
                printError("ParserError", "Expected ';' after expression")
            self.advance()
        
        return statement

    #and, or, variable reassignment
    def parseExpr(self):
        if(self.currentToken.tokenType == TOKEN_IDENTIFER):
            if(self.peekToken().tokenType == TOKEN_EQ):
                identifier = self.currentToken.tokenValue

                self.advance()
                return self.parseVariableReassignment(identifier)

        return self.parseCommonBinaryOperations(self.parseComparisionExpr, LOGICAL_GROUP)

    #not, comparision operators
    def parseComparisionExpr(self):
        if(self.currentToken.tokenType == TOKEN_KEYWORD_NOT):
            operator = self.currentToken.tokenType
            self.advance()

            rightExpr = self.parseComparisionExpr()

            return UnaryOperationNode(operator, rightExpr)

        #Else we just look for comparision operators ig
        return self.parseCommonBinaryOperations(self.parseArithmeticExpr, COMPARISION_GROUP)

    def parseArithmeticExpr(self):
        return self.parseCommonBinaryOperations(self.parseTerm, ARITHMETIC_GROUP)

    def parseTerm(self):
        return self.parseCommonBinaryOperations(self.parseUnary, TERM_GROUP)

    def parseUnary(self):
        #We only allow minus as UnaryOperation, for now
        if(self.currentToken.tokenType == TOKEN_SUB):
            operator = self.currentToken.tokenType
            self.advance()

            #Every time we get minus, we invert this condition, if even number of minus, this condition will be false
            rightExpr = self.parseUnary()

            #Return an UnaryOperationNode
            return UnaryOperationNode(operator, rightExpr)
        
        #Else we just return an Atom
        return self.parseAtom()

    def parseAtom(self):
        if(self.currentToken.tokenType in (TOKEN_INT, TOKEN_FLOAT, TOKEN_CHAR)):
            value, evalType = deduceType(self.currentToken.tokenValue, self.currentToken.tokenType == TOKEN_FLOAT, 
                                                                        self.currentToken.tokenType == TOKEN_CHAR)
            
            node = ValueNode(value, evalType)
            self.advance()

            return node
        
        if(self.currentToken.tokenType == TOKEN_IDENTIFER):
            #Get variable type from the parserSymbolTable
            variable = self.getFromNthScope(self.currentToken.tokenValue)
            if(variable == None):
                printError("ParserError", f"Undefined variable: {self.currentToken.tokenValue}")
            
            identifierType = variable[0]

            node = VariableAccessNode(identifierType, self.currentToken.tokenValue)
            self.advance()
            
            return node

        #If we find '(' then change order of operations
        if(self.currentToken.tokenType == TOKEN_LPAREN):
            self.advance()
            expr = self.parseExpr()

            #Check for closing ')'
            if(self.currentToken.tokenType != TOKEN_RPAREN):
                printError("ParserError", "Expected closing ')'")
            self.advance()

            return expr

        #All of the other stuff is just error
        printError("ParserError", "Expected Primitive types or '()' expression")