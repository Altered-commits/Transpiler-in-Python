from Node import ValueNode, BinaryOperationNode, UnaryOperationNode, VariableAssignNode, VariableAccessNode, IfNode, WhileNode, ForNode
from EvalTypes import evalTypeToString
from Printer import printError
from Token import tokenOperatorsToString

class Emitter:
    '''
    STAGE 3 of Transpiler: Final stage, Emitter. Responsible for emitting C Code given AST generated by Parser
    Example: For the code given below,
    
    var a = 10;

    Generated C Code:\n
    #include <stdint.h>

    int main(void)
    {
        uint8 a = 10;\n
        return 0;
    }
    '''
    def __init__(self, statements) -> None:
        self.statements = statements
        self.code = ""
        self.indentationLevel = 0
        #Pre-cache some indentation levels
        self.identationCache = {
            0: "",
            1: "    ",
            2: "        ",
            3: "            ",
            4: "                "
        }
    
    #------------Helper functions------------
    def incIndentationLevel(self) -> None:
        self.indentationLevel += 1
    
    def decIndentationLevel(self) -> None:
        self.indentationLevel = max(0, self.indentationLevel - 1)
    
    def getIndentation(self) -> str:
        return self.identationCache.setdefault(self.indentationLevel, " " * (self.indentationLevel * 4))

    #------------Emitter------------
    def emit(self) -> str:
        self.emitHeader()
        self.emitMainFunction()
        return self.code

    def emitHeader(self) -> None:
        #Right now the only usefull header file is <stdint.h>
        self.code += "#include <stdint.h>\n\n"
    
    def emitMainFunction(self) -> None:
        #Start of main function
        self.code += "int main(void)\n{"
        self.incIndentationLevel()
        
        previousNodeType = None
        for statement in self.statements:
            # Add newline for better readability between different types of statements
            if isinstance(statement, VariableAssignNode) and isinstance(previousNodeType, VariableAssignNode):
                if statement.isReassignment != previousNodeType.isReassignment:
                    self.code += "\n"
            elif type(statement) != type(previousNodeType):
                self.code += "\n"
            
            previousNodeType = statement
            self.emitStatement(statement)
        
        self.decIndentationLevel()

        #End of main function
        self.code += "\n    return 0;\n}"

    def emitStatement(self, node, forceNoSemicolon = False) -> None:
        shouldEndWithSemic = False
        if(isinstance(node, VariableAssignNode)):
            shouldEndWithSemic = True
            self.emitVariableAssignment(node)
        elif(isinstance(node, IfNode)):
            self.emitIfNode(node)
        elif(isinstance(node, WhileNode)):
            self.emitWhileNode(node)
        elif(isinstance(node, ForNode)):
            self.emitForNode(node)    
        #Expression
        else:
            shouldEndWithSemic = True
            self.code += self.getIndentation()
            self.emitExpression(node)
        
        #End statements for now in ';', later we will change this
        if(shouldEndWithSemic and not forceNoSemicolon):
            self.code += ";\n"
        shouldEndWithSemic = False
    
    def emitBlock(self, block) -> None:
        self.code += " {\n"
        self.incIndentationLevel()

        for statement in block:
            self.emitStatement(statement)
        
        self.decIndentationLevel()
        
        self.code += f"{self.getIndentation()}" "}\n"
    
    def emitIfNode(self, node) -> None:
        self.code += f"{self.getIndentation()}if ("
        self.emitExpression(node.ifCondition)
        self.code += ")"

        self.emitBlock(node.ifBody)

        #If the list isn't empty, else if exists
        if(node.elifBlock != []):
            for condition, body in node.elifBlock:
                self.code += f"{self.getIndentation()}else if ("
                self.emitExpression(condition)
                self.code += ")"

                self.emitBlock(body)
        
        if(node.elseBody != None):
            self.code += f"{self.getIndentation()}else"
            self.emitBlock(node.elseBody)

    def emitWhileNode(self, node) -> None:
        self.code += f"{self.getIndentation()}while ("
        self.emitExpression(node.whileCondition)
        self.code += ")"
        self.emitBlock(node.whileBody)  

    def emitForNode(self, node) -> None:
        self.code += f"{self.getIndentation()}for ("

        oldIndentationLevel = self.indentationLevel
        self.indentationLevel = 0

        self.emitStatement(node.forAssignment, True)
        self.code += "; "
        self.emitExpression(node.forCondition)
        self.code += "; "
        self.emitExpression(node.forIncrement)
        self.code += ")"

        self.indentationLevel = oldIndentationLevel
        self.emitBlock(node.forBody)

    def emitVariableAssignment(self, node) -> None:
        if(node.isReassignment):
            self.code += f"{self.getIndentation()}{node.variableName} = "
            self.emitExpression(node.assignExpr)
        else:
            cType = evalTypeToString(node.variableType)
            if cType is None:
                printError("EmitterError", f"Unsupported cType: {node.variableType}")
            
            self.code += f"{self.getIndentation()}{cType} {node.variableName} = "
            self.emitExpression(node.assignExpr)
    
    def emitExpression(self, node) -> None:
        if isinstance(node, BinaryOperationNode):
            self.emitExpression(node.leftExpr)
            self.code += f" {tokenOperatorsToString[node.operator]} "
            self.emitExpression(node.rightExpr)

        elif isinstance(node, UnaryOperationNode):
            self.code += f"{tokenOperatorsToString[node.operator]}("
            self.emitExpression(node.rightExpr)
            self.code += ")"

        elif isinstance(node, ValueNode):
            self.code += f"{node.value}"

        elif isinstance(node, VariableAccessNode):
            self.code += f"{node.variableName}"
        
        #Re-assignment
        elif isinstance(node, VariableAssignNode):
            #Temporarily reset indentation for nested expressions like these
            oldIndentationLevel = self.indentationLevel
            self.indentationLevel = 0

            self.emitVariableAssignment(node)

            self.indentationLevel = oldIndentationLevel